# app/handlers.py
from aiogram import Router, Bot
from aiogram.filters import Command  # –£–±–∏—Ä–∞–µ–º RegexpFilter
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession
import logging
from app.models import Stock, Subscription, Signal, User
from sqlalchemy import select
from datetime import datetime

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = Router()

# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
def get_main_menu():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìã –ú–æ–∏ –∞–∫—Ü–∏–∏", callback_data="list_stocks")],
        [InlineKeyboardButton(text="üìà –í—Å–µ –∞–∫—Ü–∏–∏", callback_data="list_all_stocks")],
        [InlineKeyboardButton(text="üîç –¶–µ–Ω–∞ –∞–∫—Ü–∏–∏", callback_data="check_price")],
        [InlineKeyboardButton(text="üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", callback_data="subscribe")],
        [InlineKeyboardButton(text="üìä –°–∏–≥–Ω–∞–ª—ã", callback_data="signals")],
        [InlineKeyboardButton(text="üîë –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω", callback_data="set_token")],
        [InlineKeyboardButton(text="ü§ñ –ê–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—è", callback_data="autotrading_menu")],
    ])
    return keyboard

# –ú–µ–Ω—é –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏
def get_autotrading_menu():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìä –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", callback_data="view_profile")],
        [InlineKeyboardButton(text="‚ñ∂Ô∏è –í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é", callback_data="enable_autotrading")],
        [InlineKeyboardButton(text="‚èπÔ∏è –í—ã–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é", callback_data="disable_autotrading")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –í –º–µ–Ω—é", callback_data="back_to_menu")],
    ])
    return keyboard

@router.message(Command("start"))
async def cmd_start(message: Message):
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {message.from_user.id}")
    welcome_text = (
        "üåü <b>StockBot ‚Äî –í–∞—à –ø–æ–º–æ—â–Ω–∏–∫ –Ω–∞ MOEX!</b> üåü\n\n"
        "–Ø –ø–æ–º–æ–≥—É —Å–ª–µ–¥–∏—Ç—å –∑–∞ –∞–∫—Ü–∏—è–º–∏ –∏ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å! üöÄ\n"
        "–ß—Ç–æ —è —É–º–µ—é:\n"
        "üìã –ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—à–∏ –ø–æ–¥–ø–∏—Å–∫–∏\n"
        "üìà –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞–∫—Ü–∏–∏\n"
        "üîç –£–∑–Ω–∞—Ç—å —Ü–µ–Ω—É –∞–∫—Ü–∏–∏\n"
        "üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n"
        "üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã —Ä–æ—Å—Ç–∞\n"
        "üîë –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –¥–ª—è –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏\n"
        "ü§ñ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é üëá"
    )
    await message.answer(welcome_text, parse_mode="HTML", reply_markup=get_main_menu())

@router.callback_query(lambda c: c.data == "list_stocks")
async def list_stocks(callback_query: CallbackQuery, session: AsyncSession):
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–ø—Ä–æ—Å–∏–ª —Å–ø–∏—Å–æ–∫ —Å–≤–æ–∏—Ö –∞–∫—Ü–∏–π")
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–∫–µ—Ä—ã, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–ø–∏—Å–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        result = await session.execute(
            select(Subscription.ticker).where(Subscription.user_id == user_id)
        )
        subscribed_tickers = result.scalars().all()

        if not subscribed_tickers:
            await callback_query.message.answer("–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω—É –∞–∫—Ü–∏—é. –ù–∞–∂–º–∏—Ç–µ '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è', —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –∞–∫—Ü–∏–∏.")
            return

        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ü–∏–∏, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–ø–∏—Å–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        result = await session.execute(
            select(Stock).where(Stock.ticker.in_(subscribed_tickers))
        )
        stocks = result.scalars().all()

        if not stocks:
            await callback_query.message.answer("–ê–∫—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            return

        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        for stock in stocks:
            ticker = stock.ticker
            price = stock.last_price if stock.last_price is not None else "N/A"
            button_text = f"{ticker}: {stock.name} ({price} RUB)"
            keyboard.inline_keyboard.append([
                InlineKeyboardButton(text=button_text, callback_data=f"stock_{ticker}")
            ])
        keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –í –º–µ–Ω—é", callback_data="back_to_menu")])
        await callback_query.message.answer("üìã <b>–í–∞—à–∏ –∞–∫—Ü–∏–∏:</b>", parse_mode="HTML", reply_markup=keyboard)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞–∫—Ü–∏–π: {e}")
        await callback_query.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞–∫—Ü–∏–π.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "list_all_stocks")
async def list_all_stocks(callback_query: CallbackQuery, session: AsyncSession):
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–ø—Ä–æ—Å–∏–ª —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∞–∫—Ü–∏–π")
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ü–∏–∏ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã stocks
        result = await session.execute(select(Stock))
        stocks = result.scalars().all()

        if not stocks:
            await callback_query.message.answer("–í –±–∞–∑–µ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞–∫—Ü–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            return

        keyboard = InlineKeyboardMarkup(inline_keyboard=[])
        for stock in stocks:
            ticker = stock.ticker
            price = stock.last_price if stock.last_price is not None else "N/A"
            button_text = f"{ticker}: {stock.name} ({price} RUB)"
            keyboard.inline_keyboard.append([
                InlineKeyboardButton(text=button_text, callback_data=f"stock_{ticker}")
            ])
        keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –í –º–µ–Ω—é", callback_data="back_to_menu")])
        await callback_query.message.answer("üìà <b>–í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞–∫—Ü–∏–∏:</b>", parse_mode="HTML", reply_markup=keyboard)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Å–µ—Ö –∞–∫—Ü–∏–π: {e}")
        await callback_query.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∞–∫—Ü–∏–π.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "check_price")
async def prompt_check_price(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} —Ö–æ—á–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ü–µ–Ω—É –∞–∫—Ü–∏–∏")
    await callback_query.message.answer("üîç –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "subscribe")
async def prompt_subscribe(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} —Ö–æ—á–µ—Ç –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∞–∫—Ü–∏–∏")
    await callback_query.message.answer("üîî –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "signals")
async def prompt_signals(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} –∑–∞–ø—Ä–æ—Å–∏–ª —Å–∏–≥–Ω–∞–ª—ã")
    await callback_query.message.answer("üìä –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "set_token")
async def prompt_set_token(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} —Ö–æ—á–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω")
    await callback_query.message.answer("üîë –í–≤–µ–¥–∏—Ç–µ –≤–∞—à —Ç–æ–∫–µ–Ω T-Invest API (–¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å t_):")
    await callback_query.answer()

# –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏—é –≤–º–µ—Å—Ç–æ RegexpFilter
@router.message(lambda message: message.text.startswith('t_'))
async def save_token(message: Message, session: AsyncSession):
    user_id = message.from_user.id
    token = message.text.strip()
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –≤–≤—ë–ª —Ç–æ–∫–µ–Ω T-Invest API: {token[:10]}...")

    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
        result = await session.execute(select(User).where(User.user_id == user_id))
        user = result.scalars().first()

        if user:
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω
            user.tinkoff_token = token
        else:
            # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            new_user = User(user_id=user_id, tinkoff_token=token)
            session.add(new_user)

        await session.commit()
        await message.answer("‚úÖ –¢–æ–∫–µ–Ω —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω! –¢–µ–ø–µ—Ä—å —è –º–æ–≥—É —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –∑–∞ –≤–∞—Å.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç–æ–∫–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

@router.callback_query(lambda c: c.data == "autotrading_menu")
async def autotrading_menu(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} –æ—Ç–∫—Ä—ã–ª –º–µ–Ω—é –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏")
    await callback_query.message.answer("ü§ñ <b>–ú–µ–Ω—é –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏:</b>", parse_mode="HTML", reply_markup=get_autotrading_menu())
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "view_profile")
async def view_profile(callback_query: CallbackQuery, session: AsyncSession):
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–ø—Ä–æ—Å–∏–ª –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–æ—Ñ–∏–ª—è")
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
        result = await session.execute(select(User).where(User.user_id == user_id))
        user = result.scalars().first()

        if not user or not user.tinkoff_token:
            await callback_query.message.answer("üîë –£ –≤–∞—Å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Ç–æ–∫–µ–Ω T-Invest API. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ —á–µ—Ä–µ–∑ –º–µ–Ω—é.")
            return

        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        result = await session.execute(
            select(Subscription.ticker).where(Subscription.user_id == user_id)
        )
        subscribed_tickers = result.scalars().all()

        profile_text = (
            f"üìä <b>–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</b>\n\n"
            f"üÜî –í–∞—à ID: {user_id}\n"
            f"üîë –¢–æ–∫–µ–Ω T-Invest API: {user.tinkoff_token[:10]}...\n"
            f"üìã –ü–æ–¥–ø–∏—Å–∫–∏: {', '.join(subscribed_tickers) if subscribed_tickers else '–ù–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫'}\n"
        )
        await callback_query.message.answer(profile_text, parse_mode="HTML", reply_markup=get_autotrading_menu())
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        await callback_query.message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –ø—Ä–æ—Ñ–∏–ª—è.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "enable_autotrading")
async def enable_autotrading(callback_query: CallbackQuery, session: AsyncSession):
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –≤–∫–ª—é—á–∏–ª –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é")
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
        result = await session.execute(select(User).where(User.user_id == user_id))
        user = result.scalars().first()

        if not user:
            await callback_query.message.answer("‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ç–æ–∫–µ–Ω T-Invest API.")
            return

        user.autotrading_enabled = True
        await session.commit()
        await callback_query.message.answer("‚ñ∂Ô∏è –ê–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—è –≤–∫–ª—é—á–µ–Ω–∞!", reply_markup=get_autotrading_menu())
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        await callback_query.message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "disable_autotrading")
async def disable_autotrading(callback_query: CallbackQuery, session: AsyncSession):
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –≤—ã–∫–ª—é—á–∏–ª –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é")
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
        result = await session.execute(select(User).where(User.user_id == user_id))
        user = result.scalars().first()

        if not user:
            await callback_query.message.answer("‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ç–æ–∫–µ–Ω T-Invest API.")
            return

        user.autotrading_enabled = False
        await session.commit()
        await callback_query.message.answer("‚èπÔ∏è –ê–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∞!", reply_markup=get_autotrading_menu())
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        await callback_query.message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª–∏.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data == "back_to_menu")
async def back_to_menu(callback_query: CallbackQuery):
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {callback_query.from_user.id} –≤–µ—Ä–Ω—É–ª—Å—è –≤ –º–µ–Ω—é")
    await callback_query.message.answer("üåü –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=get_main_menu())
    await callback_query.answer()

@router.callback_query(lambda c: c.data.startswith("stock_"))
async def process_stock_selection(callback_query: CallbackQuery, session: AsyncSession):
    ticker = callback_query.data.split("_")[1]
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –≤—ã–±—Ä–∞–ª –∞–∫—Ü–∏—é {ticker}")

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîç –¶–µ–Ω–∞", callback_data=f"price_{ticker}")],
        [InlineKeyboardButton(text="üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", callback_data=f"subscribe_{ticker}")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="list_stocks")]
    ])
    await callback_query.message.answer(f"üìä –í—ã –≤—ã–±—Ä–∞–ª–∏ <b>{ticker}</b>. –ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å?", parse_mode="HTML", reply_markup=keyboard)
    await callback_query.answer()

@router.callback_query(lambda c: c.data.startswith("price_"))
async def process_price(callback_query: CallbackQuery, session: AsyncSession):
    ticker = callback_query.data.split("_")[1]
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /price –¥–ª—è {ticker} –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    try:
        result = await session.execute(select(Stock).where(Stock.ticker == ticker))
        stock = result.scalars().first()
        if not stock:
            await callback_query.message.answer(f"–ê–∫—Ü–∏—è {ticker} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ.")
            return

        await callback_query.message.answer(
            f"üí∞ <b>{stock.ticker}</b> ({stock.name})\n"
            f"üìà –¶–µ–Ω–∞: {stock.last_price} RUB\n"
            f"üìä –û–±—ä—ë–º: {stock.volume} –∞–∫—Ü–∏–π\n"
            f"üïí –û–±–Ω–æ–≤–ª–µ–Ω–æ: {stock.updated_at}",
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω—ã –¥–ª—è {ticker}: {e}")
        await callback_query.message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {ticker}.")
    await callback_query.answer()

@router.callback_query(lambda c: c.data.startswith("subscribe_"))
async def process_subscribe(callback_query: CallbackQuery, session: AsyncSession):
    ticker = callback_query.data.split("_")[1]
    user_id = callback_query.from_user.id
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /subscribe –¥–ª—è {ticker} –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
    try:
        stock = await session.execute(select(Stock).where(Stock.ticker == ticker))
        stock = stock.scalars().first()
        if not stock:
            await callback_query.message.answer(f"–ê–∫—Ü–∏—è {ticker} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
            return
        subscription = await session.execute(
            select(Subscription).where(
                Subscription.user_id == user_id,
                Subscription.ticker == ticker
            )
        )
        if subscription.scalars().first():
            await callback_query.message.answer(f"–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ {ticker}.")
            return
        new_subscription = Subscription(user_id=user_id, ticker=ticker)
        session.add(new_subscription)
        await session.commit()
        await callback_query.message.answer(f"üîî –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ <b>{ticker}</b>!", parse_mode="HTML")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–∞ {ticker}: {e}")
        await callback_query.message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–∞ {ticker}.")
    await callback_query.answer()

@router.message(Command("price"))
async def cmd_price(message: Message, session: AsyncSession):
    ticker = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else None
    if not ticker:
        await message.answer("üîç –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
        return
    await process_price(CallbackQuery(
        id="manual_price",
        from_user=message.from_user,
        message=message,
        chat_instance="manual",
        data=f"price_{ticker}"
    ), session)

@router.message(Command("subscribe"))
async def cmd_subscribe(message: Message, session: AsyncSession):
    ticker = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else None
    if not ticker:
        await message.answer("üîî –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
        return
    await process_subscribe(CallbackQuery(
        id="manual_subscribe",
        from_user=message.from_user,
        message=message,
        chat_instance="manual",
        data=f"subscribe_{ticker}"
    ), session)

@router.message(Command("signals"))
async def cmd_signals(message: Message, session: AsyncSession):
    ticker = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else None
    if not ticker:
        await message.answer("üìä –í–≤–µ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä –∞–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, SBER.ME):")
        return
    try:
        signals = await session.execute(
            select(Signal).where(Signal.ticker == ticker)
        )
        signals = signals.scalars().all()
        if not signals:
            await message.answer(f"–°–∏–≥–Ω–∞–ª—ã –¥–ª—è {ticker} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
            return
        response = f"üìä <b>–°–∏–≥–Ω–∞–ª—ã –¥–ª—è {ticker}</b>:\n" + "\n".join([f"üîπ {s.signal_type}: {s.value} ({s.created_at})" for s in signals])
        await message.answer(response, parse_mode="HTML")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è {ticker}: {e}")
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è {ticker}.")